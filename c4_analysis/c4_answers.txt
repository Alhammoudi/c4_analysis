1. What is the purpose of the next() function, and how does it contribute to the compilation process?
The next() function in C4 is responsible for lexical analysis, the first stage of compilation where raw source code is converted into structured tokens. It reads the input character by character, classifying keywords, operators, numbers, and identifiers while skipping whitespace and comments. It also processes string and numeric literals, ensuring that tokens are properly categorized before they reach the parser. This function plays a crucial role in simplifying the input for later stages, allowing the parser to work with a cleaner, structured sequence rather than raw text. Without next(), the compiler would have to process characters directly at every stage, making the parsing process significantly more complex.

2. How does C4 handle symbol resolution (e.g., variables, functions)?
C4 uses a symbol table to keep track of all identifiers, including variables, functions, and system calls. When an identifier is encountered, the compiler either registers it as a new entry (if itâ€™s a declaration) or looks it up in the table to retrieve its type and memory location. The symbol table helps distinguish between different classes of identifiers, such as global variables, local variables, functions, and system calls, ensuring that each reference points to the correct location in memory. Since C4 is a minimalist compiler, its symbol resolution is relatively straightforward, but it effectively prevents errors related to undefined variables or functions by ensuring all references are properly linked.

3. What are the limitations of C4 as a compiler? What features of C does it not support?
C4 is designed to be compact and self-hosting, but this simplicity comes at the cost of missing several features present in full-fledged C compilers. It does not support structs, unions, floating-point arithmetic, or complex data types, limiting the kinds of programs that can be compiled. Additionally, it lacks an optimization phase, meaning that the generated code is not as efficient as that produced by modern compilers. Error handling is also minimal, making it difficult to debug issues compared to standard C compilers, which provide detailed diagnostics. Despite these limitations, C4 serves as an excellent learning tool for understanding compiler design and self-hosting principles.

4. How does C4 achieve self-hosting, and what are the implications of this design?
C4 is capable of compiling itself, a property known as self-hosting. It achieves this by implementing just enough of the C language to parse, analyze, and generate executable code for its own source file. This means that improvements or modifications to C4 can be compiled using the compiler itself, creating a feedback loop for further development. Self-hosting also demonstrates that C4, despite its simplicity, is a fully functional compiler. The ability to compile itself also makes C4 more portable since it does not rely on external tools beyond an initial bootstrap. This design choice reinforces the core principles of compiler construction while making C4 a practical example of a minimal yet complete compiler.